<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Three.js Scene</title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      display: block;
    }
  </style>
  <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.min.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/loaders/GLTFLoader.js",
                "three/examples/jsm/loaders/FBXLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/loaders/FBXLoader.js",
                "three/src/loaders/TextureLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/src/loaders/TextureLoader.js"
            }
        }
    </script>
</head>

<body>
  <script>
    (async () => {
      const THREE = await import("three");
      const { GLTFLoader } = await import('three/examples/jsm/loaders/GLTFLoader');
      const { FBXLoader } = await import("three/examples/jsm/loaders/FBXLoader");
      const { TextureLoader } = await import("three/src/loaders/TextureLoader");

      // MARK: Utils
      var model;
      const loadModel = async (modelUrl, textureUrl = null) => {
        const extension = modelUrl.split('.').pop().toLowerCase();
        let model;

        if (extension === 'fbx') {
          model = await new Promise((resolve, reject) => {
            new FBXLoader().load(modelUrl, resolve, undefined, reject);
          });
        } else if (extension === 'glb' || extension === 'gltf') {
          const gltf = await new Promise((resolve, reject) => {
            new GLTFLoader().load(modelUrl, resolve, undefined, reject);
          });
          model = gltf.scene;
        } else {
          throw new Error(`Unsupported model format: .${extension}`);
        }

        if (!textureUrl) return model;

        const texture = await new Promise((resolve, reject) => {
          new TextureLoader().load(
            textureUrl,
            (tex) => {
              if (tex.image && tex.image.complete) resolve(tex);
              else tex.image.onload = () => resolve(tex);
            }, undefined, reject);
        });
        model.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({ map: texture });
          }
        });
        return model;
      }

      // Three.js variables
      const halfPI = Math.PI / 2;
      const quarterPI = Math.PI / 4;
      const vecX = new THREE.Vector3(1, 0, 0), vecY = new THREE.Vector3(0, 1, 0), vecZ = new THREE.Vector3(0, 0, 1);
      var reserveQuaternion = new THREE.Quaternion();
      function applyEuler(bone, rotX, rotY, rotZ) {
        let oldParent = bone.parent;
        scene.attach(bone);

        reserveQuaternion.setFromAxisAngle(vecX, rotX);
        bone.quaternion.copy(reserveQuaternion);
        reserveQuaternion.setFromAxisAngle(vecY, rotY);
        bone.applyQuaternion(reserveQuaternion);
        reserveQuaternion.setFromAxisAngle(vecZ, rotZ);
        bone.applyQuaternion(reserveQuaternion);

        oldParent.attach(bone);
      }

      const pos_mods = { x: [1, 0], y: [-1, 0], z: [-1, 0] }
      function updateAvatarPose(data) {
        if (!model || !data.body) return;

        Object.keys(data.body).forEach(part => {
          const bone = model.getObjectByName(part);
          if (!bone) {
            console.log(`Bone ${part} not found`);
            return;
          }
          if (data.body[part].position) {
            const position = data.body[part].position;
            const globalPos = new THREE.Vector3(
              position[0] * pos_mods.x[0] + pos_mods.x[1],
              position[1] * pos_mods.y[0] + pos_mods.y[1],
              position[2] * pos_mods.z[0] + pos_mods.z[1]
            );

            if (bone.parent.isBone) {
              if (bone.parent.children.length === 1) {
                bone.parent.lookAt(globalPos);
                bone.parent.rotateX(halfPI);
              }
            }

            bone.parent.worldToLocal(globalPos);
            bone.position.copy(globalPos);
          }
          if (data.body[part].rotation) {
            // yaw, roll, pitch
            const rotation = data.body[part].rotation;

            // I hate gimbal lock
            // applyEuler(bone, rotation[0], rotation[2], rotation[1]);
            
            // if (part === "Bip01_Spine2") {
            //   applyEuler(bone, rotation[0] + halfPI, -rotation[2], rotation[1] + halfPI);
            // }
            // if (part === "Bip01_Head1") {
            //   applyEuler(bone, rotation[0] - halfPI, rotation[2], rotation[1] + halfPI)
            // }
            // if (part === "Bip01_Pelvis") {
            //   applyEuler(bone, rotation[2], rotation[0], rotation[1]);
            // }
          }
        });

        model.updateMatrixWorld(true);
      }

      // MARK: Render
      var customData = "{}";
      if (window.getCustomData) {
        customData = await window.getCustomData();
      }
      data = JSON.parse(customData);
      // console.log("Custom data from CLI:", customData);

      const scene = new THREE.Scene();
      const ratio = window.innerWidth / window.innerHeight;
      const camera = new THREE.PerspectiveCamera(75, ratio, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // model load
      // const model = await loadModel('https://ioann44.ru/skeleton/skeleton_model.fbx', 'https://ioann44.ru/skeleton/skeleton_texture.png');
      model = await loadModel(`https://ioann44.ru/models/nanosuit.glb`);

      const scaleFactor = 0.02;
      model.scale.set(scaleFactor, scaleFactor, scaleFactor);
      let hips = null;
      model.traverse((obj) => {
        if (obj.isBone && obj.name.toLowerCase().includes('hips')) {
          hips = obj;
        }
      });
      if (hips) {
        const hipsWorldPos = new THREE.Vector3();
        hips.getWorldPosition(hipsWorldPos);
        model.position.sub(hipsWorldPos);
      }
      // model.rotation.y = Math.PI;
      hips.rotation.y = Math.PI;
      // show model
      scene.add(model);

      scene.add(new THREE.SkeletonHelper(model));
      scene.add(new THREE.AxesHelper(5));

      // draw points
      if (data.points) {
        const pointGeometry = new THREE.SphereGeometry(0.02);
        const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        Object.values(data.points).forEach(arr => {
          pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
          pointMesh.position.copy(new THREE.Vector3(arr[0], -arr[1], -arr[2]));
          scene.add(pointMesh);
        });
      }

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7.5);
      scene.add(light);
      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      camera.position.z = 1.5;

      updateAvatarPose(data);

      renderer.render(scene, camera);
      window.renderDone = true;
    })();
  </script>
</body>

</html>