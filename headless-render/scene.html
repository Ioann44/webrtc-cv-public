<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Three.js Scene</title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      display: block;
    }
  </style>
  <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.min.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/loaders/GLTFLoader.js",
                "three/examples/jsm/loaders/FBXLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/loaders/FBXLoader.js",
                "three/src/loaders/TextureLoader": "https://cdn.jsdelivr.net/npm/three@0.173.0/src/loaders/TextureLoader.js"
            }
        }
    </script>
</head>

<body>
  <script>
    (async () => {
      const THREE = await import("three");
      const { GLTFLoader } = await import('three/examples/jsm/loaders/GLTFLoader');
      const { FBXLoader } = await import("three/examples/jsm/loaders/FBXLoader");
      const { TextureLoader } = await import("three/src/loaders/TextureLoader");

      // MARK: Utils
      const loadModel = async (modelUrl, textureUrl = null) => {
        const extension = modelUrl.split('.').pop().toLowerCase();
        let model;

        if (extension === 'fbx') {
          model = await new Promise((resolve, reject) => {
            new FBXLoader().load(modelUrl, resolve, undefined, reject);
          });
        } else if (extension === 'glb' || extension === 'gltf') {
          const gltf = await new Promise((resolve, reject) => {
            new GLTFLoader().load(modelUrl, resolve, undefined, reject);
          });
          model = gltf.scene;
        } else {
          throw new Error(`Unsupported model format: .${extension}`);
        }

        if (!textureUrl) return model;

        const texture = await new Promise((resolve, reject) => {
          new TextureLoader().load(
            textureUrl,
            (tex) => {
              if (tex.image && tex.image.complete) resolve(tex);
              else tex.image.onload = () => resolve(tex);
            }, undefined, reject);
        });
        model.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({ map: texture });
          }
        });
        return model;
      }

      // MARK: Render
      const customData = await window.getCustomData();
      // const customData = "red";
      console.log("Custom data from CLI:", customData);

      const color = customData === "red" ? 0xff0000 : 0x00ff00;

      const scene = new THREE.Scene();
      const ratio = window.innerWidth / window.innerHeight;
      const camera = new THREE.PerspectiveCamera(75, ratio, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // model load
      // const model = await loadModel('https://ioann44.ru/skeleton/skeleton_model.fbx', 'https://ioann44.ru/skeleton/skeleton_texture.png');
      const model = await loadModel(`https://ioann44.ru/models/nanosuit.glb`);

      const scaleFactor = 0.04;
      model.scale.set(scaleFactor, scaleFactor, scaleFactor);
      let hips = null;
      model.traverse((obj) => {
        if (obj.isBone && obj.name.toLowerCase().includes('hips')) {
          hips = obj;
        }
      });
      if (hips) {
        const hipsWorldPos = new THREE.Vector3();
        hips.getWorldPosition(hipsWorldPos);
        model.position.sub(hipsWorldPos);
      }
      // model.rotation.y = Math.PI;
      hips.rotation.y = Math.PI;
      scene.add(model);

      scene.add(new THREE.SkeletonHelper(model));
      scene.add(new THREE.AxesHelper(5));

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7.5);
      scene.add(light);
      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      camera.position.z = 5;

      renderer.render(scene, camera);
      window.renderDone = true;
    })();
  </script>
</body>

</html>